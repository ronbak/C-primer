### 练习6.1
- **形参** 只有在函数调用是才分配空间，并在函数结束时释放空间
- **实参** 预先分配存储空间并初始化。


### 练习6.2
- (a). 在函数体内定义的变量在函数调用结束时就会被释放，所以函数的返回值不应该使用在函数内定义的变量，可以使用全局变量或者指针。
- (b). 在定义函数的时候没有表明函数的返回值类型。
- (c). 在函数的参数表中定义了相同名称的形参
- (d). 定义函数的时候没有将函数中的语句用"｛｝"括起来

### 练习6.3

### 练习6.4

### 练习6.5

### 练习6.6
- **形参** 在函数体内定义，作用域只在函数体内有效，并在函数调用结束后释放。
- **局部变量** 在定义的“块”中可以直接使用，在其作用域外不能被直接调用，函数调用结束后会被销毁。
- **局部静态变量** 在定义的“块”中可以直接调用，在函数调用结束后不会被销毁。

### 练习6.7

### 练习6.8

### 练习6.9

### 练习6.10

### 练习6.11

### 练习6.12
  - 引用的方式更加方便简洁！

### 练习6.13
```
void f(T) 与 void f(&T)

```
- 两个的区别是函数传递的参数，一个是以形参的形式进行参数的传递，一个是以引用的方式进行参数的传递。


### 练习6.14
- 当函数需要传递多个变量的值时，应该使用引用类型
- 当形参需要是以常数传递的时候，则不需要使用引用类型

### 练习6.15
- 因为在使用字符串s的时候并不需要改变字符串的内容，则使用常量引用比较安全。
- 函数并没有改变c的值
- 如果s是普通引用，可能在函数的调用中，改变s的内容，造成后面对s的操作的错误结果。
- occurs是常量引用时，则不能改变occurs的值！

### 练习6.16
```
bool is_empty(string &s)
{
  return s.empty();
}
```
- 函数不能调用常量字符串，限制了它的使用范围，可改为：
```
bool is_mepty(const string &s)
{
  return s.empty();
}
```

### 练习6.17
- 使用的参数不相同，因为查看字符串中是否有大写字母，并不需要更改字符串的内容，所以使用**const &** ，而更改字符串的小写字母为大写时需要改变字符串的内容而使用普通的引用作为参数。

### 练习6.18
- (a).比较两个matrix（矩阵）的大小、是否相等之类。
- (b).截取传入迭代器中的部分（int），然后输出新的迭代器。

### 练习6.19
- (a).参数个数不匹配
- (b).合法
- (c).合法
- (d).合法

### 练习6.20
- 在传入的形参不需要改变其值时，使用常量引用。
- 如果设成了普通引用，则会使函数不能调用常量实参！而且可能造成参数值的改变。

### 练习6.21

### 练习6.22

### 练习6.23

### 练习6.24
> http://stackoverflow.com/questions/26530659/confused-about-array-parameters#   

```
void print10(const int (&a)[10])
{
    for (auto i : a) { std::cout << i << "\n"; }
}
```

### 练习6.25

### 练习6.26

### 练习6.27

### 练习6.28
- 因为il是std::initializer_list<string> 类型，而范围for语句中使用的是常量引用所以应该是std::string

### 练习6.29
- 应该，std::initializer_list对象中的元素永远是常量值，所以应该使用常量引用！

### 练习6.30
> 编译器：Dev-C++ 5.11
1. 错误：[Error] return-statement with no value, in function returning 'bool' [-fpermissive]
2. 第二个错没有检查出来。

### 练习6.31
> 1. 当返回的引用是函数内的局部变量时，返回的引用无效
2. ？？？ 非常量方法返回常量引用的时候，返回值的类型不匹配。？？？

### 练习6.32   
- 合法！！！
验证程序如下：

```
#include <iostream>

int &get(int *arry, int index)
{
	return arry[index];
}

int main()
{
	int ia[10];
	for(int i = 0; i != 10; ++i)
		get(ia, i) = i;
	for(auto j : ia)
		std::cout << j << " " << std::endl;
}

```
程序含义： 将0~9赋给ia数组。

### 练习6.33

### 练习6.34
> 1. 可能结果为负，成为一个死循环。
2. 可能停止在0，造成结果的错误。

### 练习6.35
> 若使用val-- 则会使循环成为一个死循环。
可以使用--val来代替

### 练习6.36

### 练习6.37

### 练习6.38
